using OpenCvSharp;

public class ChessboardPerspectiveCorrection
{
    public static Mat CorrectPerspective(Mat inputImage)
    {
        // 轉換成灰階影像
        Mat gray = new Mat();
        Cv2.CvtColor(inputImage, gray, ColorConversionCodes.BGR2GRAY);

        // 找出棋盤格角點
        Size patternSize = new Size(7, 7); // 假設是6x6的棋盤格(7x7個交叉點)
        Point2f[] corners;
        bool found = Cv2.FindChessboardCorners(gray, patternSize, out corners,
            ChessboardFlags.AdaptiveThresh | ChessboardFlags.NormalizeImage);

        if (!found)
        {
            throw new Exception("無法找到棋盤格角點");
        }

        // 優化角點位置
        Cv2.CornerSubPix(gray, corners, new Size(11, 11), new Size(-1, -1),
            new TermCriteria(CriteriaTypes.Eps | CriteriaTypes.MaxIter, 30, 0.1));

        // 建立理想的棋盤格點位置（未變形時的位置）
        Point2f[] idealPoints = new Point2f[patternSize.Width * patternSize.Height];
        float squareSize = 50.0f; // 每個方格的大小（像素）
        for (int i = 0; i < patternSize.Height; i++)
        {
            for (int j = 0; j < patternSize.Width; j++)
            {
                idealPoints[i * patternSize.Width + j] = new Point2f(
                    j * squareSize,
                    i * squareSize
                );
            }
        }

        // 計算透視變換矩陣
        Mat perspectiveMatrix = Cv2.GetPerspectiveTransform(corners, idealPoints);

        // 進行透視校正
        Mat correctedImage = new Mat();
        Cv2.WarpPerspective(inputImage, correctedImage, perspectiveMatrix,
            new Size(patternSize.Width * squareSize, patternSize.Height * squareSize));

        return correctedImage;
    }

    public static void GetDeformationParameters(Mat perspectiveMatrix)
    {
        // 從透視變換矩陣中提取變形參數
        // 這裡可以根據需求分析旋轉角度、傾斜度等
        
        // 例如提取旋轉角度（這只是簡化的示例）
        double angle = Math.Atan2(perspectiveMatrix.At<double>(1, 0), 
                                perspectiveMatrix.At<double>(0, 0)) * 180 / Math.PI;
        
        Console.WriteLine($"Rotation angle: {angle} degrees");
    }
}
